mesh_build = 0

n_uniform_refinements = 2
n_levels_coarsen = 3 # error if not >= 3, this is how many MG levels I will make

x_range = 2
y_range = 2
z_range = 2

x_size = 1.
y_size = 1.
z_size = 1.

print_matrix = false

level_view = 1

gamma_R = 0.0

gamma_I = 0.0

# Maximum number of refinement steps
max_r_steps = 5

# Maximum h refinement level for an element.
max_r_level = 5

# Percentage of elements to refine at each step
refine_percentage = 0.7

# Percentage of elements to (attempt to) coarsen at each step
coarsen_percentage = 0.0

# Option to uniformly or adaptively refine.
# If uniform_refine == 1, uniform refinement is done.
# If uniform_refine == 0, adaptive refinement is done.
uniform_refine = 0

# uniform-refine is no longer effective. Change n_uniform_refinements instead.

# Basis function type (as named in enum_fe_family.h)
approx_type = LAGRANGE

# minimum approximation order
# Use approx_order = 1 or 2 for LAGRANGE elements
# Use approx_order = 2 or 3 for CLOUGH elements
# Use approx_order = 3 or higher for HERMITE elements
# Use approx_order = 1 or higher for other elements
approx_order = 1

# Use what type of error indicator?
# exact => comparison with analytic solution
# kelly => inter-element normal derivative jumps
# patch => patch gradient recovery
# uniform => uniform refinement
indicator_type = kelly

# Mesh refinement type: h, p, matchedhp, or hp
# Use HIERARCHIC or HERMITE functions with p/matchedhp/hp,
# Use an exact indicator with matchedhp/hp.
# matchedhp refinement stupidly does both h and p or neither
# on every element; hp refinement tries to do one or the other
refinement_type = h

# Mesh dimensionality
# We generate 1D meshes on [-1, 0].
# We load lshaped.xda for 2 dimensional problems, lshaped3D.xda for 3
dimension = 3

# Element type - tensor or simplex
# simplex is currently only supported in 2D
# Use element_type = tensor for HERMITE elements
# Use element_type = simplex for CLOUGH elements
element_type = tensor

# Use higher quadrature order when computing errors?
extra_error_quadrature = 0

# Solve a singular or non-singular problem?
singularity = true

# Output intermediate solves?
output_intermediate = false

